# Fibonacci Service

The Fibonacci Service is a Go-based REST API that returns the Nth Fibonacci numbers for any given index N. 
It uses Redis for caching and includes a background job to precompute Fibonacci sequences for improved performance.

---

## Features
- **Fibonacci Calculation**: Compute Fibonacci numbers on demand via API.
- **Caching**: Caches computed values in Redis to minimize redundant calculations.
- **Scheduled Jobs**: Periodically precomputes Fibonacci sequences up to a configurable limit.
- **Environment Configuration**: Configurable via `.env` file.

---

## Design considerations
- **Redis vs local cache**: 
  - Redis for better availability and scalability
  - In case of loss of an instance data will be available in redis, no need to compute the data once the pod is back up
  - Multiple instances can access the same cached data no need to compute the data once the cache is populated
- **Algo used for computing fibonacci sequence** 
  - Using 2 different algo for generating the fibonacci sequence
  - **Linear**
    - The periodic scheduled job uses linear algo for populating the fibonacci sequence in the cache
    - It check if any other job is currently in PROGRESS and tries to acquires a LOCK by inserting LOCK_KEY in redis
    - The LOCK_KEY will be removed once 
      - Job is completed 
      - Job is timed out (job context ttl)
      - Key is timed out (LOCK_KEY has a ttl so that if the pod is down other pods can start the Job)
    - The job looks for the MAX populated key before generating new sequence and generates the sequence from the MAX generated by other Job
  - **Matrix Multiplication**
    - Using the matrix multiplication to generate the Nth fibonacci number on the fly
    - The runtime complexity for this algo is O(logN) which is helpful in generating fibonacci number when there is a Cache Miss
    - after the value is generated it is cached in Memory and returned
    - This has a timeout set for 10 sec for dev purpose so that users dont wait for long time if computation is taking time

## API Endpoints
GET /fibonacci/{n}

- **200 Ok**
```json
{
  "result": "Fibonacci result as string",
  "n": "Requested number"
}
```
```html
Description: Computes the Fibonacci number for the given n.
Parameters:
n (path parameter): A non-negative integer.
```
- **400 Bad Request**
```json
{"error":"Invalid n",
  "code":10001
}
```
```html
Error: Description of errpr
code: A non-negative integer code for the error.
```

## Error Response Codes
```html
10001 -> Invalid Input
1ooo2 -> Internal Server Error
10003 -> Request Time Out
```
===
```text
fibonacci-service/
├── Dockerfile                  # Docker file for containerizing the application
├── README.md                   # Project description and documentation
├── go.mod                      # Go module file
├── go.sum                      # Go checksum file
├── .env                        # Environment variables for local development (e.g., Redis, config)
├── build.sh                    # build file to build and push docker images to registry
├── app-deployment.yaml         # Yaml file containing k8s config for deployment of the service
├── redis-deployment.yaml         # Yaml file containing k8s config for deployment of redis
├── cmd/
│   └──  main.go              # The main Go file to run the service
├── internal/
│   ├── config/                 # Configuration management
│   │   └── config.go            # Configuration file handling
│   ├── handler/              # Business logic related to Fibonacci sequence
│   │   └── fibonacci.go         # Api Handler
│   ├── redis_client/           # Redis client initialization and helper functions
│   │   └── redis_client.go      # Redis initialization and helper methods
│   └── jobs/                   # Background jobs related to Fibonacci cache population
│        └── cache_job.go   # Job to periodically populate Redis cache
├── pkg/
│   └── common/                 # Common structures, models, and utilities used across the app
│       └──  response.go          # Common API response structures
├── scripts/                    # Helper scripts (e.g., migration, build, etc.)
└── tests/                       # tests
    ├── api/                    # API endpoint tests
    └── fibonacci_test.go    # Unit tests for Fibonacci functions

```

---

## Requirements
- **Go**: Version 1.23 or higher
- **Redis**: Redis server running and
- **Docker**: Optional, for containerized deployment
- **Minikube**: Optional, for containerized deployment to k8s
- **Kubectl**: Optional, for interacting with k8s cluster

---

## Installation and run in local

```bash
cd fibonacci-service

go get github.com/redis/go-redis/v9   
go get github.com/go-redis/redismock/v8
go get github.com/stretchr/testify/assert 
go get github.com/joho/godotenv
go get github.com/gorilla/mux


go mod init
go mod tidy
go test -v
go run main.go
```

---

### Deployment requirements

Docker Desktop
https://www.docker.com/products/docker-desktop/

minikube installation :
https://minikube.sigs.k8s.io/docs/start

kubectl installation :
```bash 
minikube kubectl -- get po -A
```
to pull redis image
```text
docker image pull redis
```
Once docker is up in local
for local testing you can run redis via
```shell
docker run --name my-redis -p 6379:6379 -d redis
```

### Deploying to k8s cluster
## Deploying redis in k8s cluster
```shell
kubectl apply -f redis-deployment.yaml
```

## Deploying app in k8s cluster
```shell
kubectl apply -f app-deployment.yaml
```

---
## Debuging issues

- You should be see logs below to show the progress
```shell
2024/12/01 14:45:36 Lock acquired: FIBONACCI_JOB_PROGRESS
2024/12/01 14:45:36 Populating cache with MAX_N_TO_GENERATE=9999999999
2024/12/01 14:45:36 Found pre populated key: 123700
2024/12/01 14:45:36 CachedIndex till - 123700
```

---

## Improvements that can be made
- Add pprof for performance monitoring
- https://pkg.go.dev/runtime/pprof
- Adding Cache hit and miss metrics
- expose healthcheck endpoint for readiness probe